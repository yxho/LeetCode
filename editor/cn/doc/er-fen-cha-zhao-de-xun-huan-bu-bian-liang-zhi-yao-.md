### 解题思路
二分查找属于经典的算法， 但是想要完全写对（这里指的不是整型溢出的问题）一个二分查找， 实际上还是需要一定的基本功的
如果你没有真正的理解二分查找， 你可能就会发现你的二分查找成勋在处理边界条件上总是出问题， 例如 < 还是 =< ，用不用 +1, 总是会搞错

实际上， 你之所以在这些边界条件上犯错误， 就是没有真正的定义清楚程序中的每一个变量。
对于二分查找， 最重要的就是要弄清楚 r, l 这两个分别指向 nums 左右两边的索引的定义

下面就对这两个变量进行说明：
### 代码
```cpp []
// 常规写法 1
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return -1;
        int l = 0, r = nums.size();
        while(l < r){
            int m = (l + r) / 2;
            if(nums[m] == target)
                return m;
            else if(nums[m] > target)
                r = m;
            else
                l = m + 1;
        }
        return -1;
    }
};
```
```cpp []
// 常规写法 2
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return -1;
        int l = 0, r = nums.size() - 1;
        while(l <= r){
            int m = (l + r) / 2;
            if(nums[m] == target)                                                                                                                                                                                                                                                       
                return m;
            else if(nums[m] > target)
                r = m - 1;
            else
                l = m + 1;
        }
        return -1;
    }
};
```

### 循环不变量
观察上面的代码的异同之处
![二分查找.png](https://pic.leetcode-cn.com/8dfd46d9ba8374bae37d3583def5878bd7462698dc9d2311c159d110aecc7557-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png)

主要存在于 3 个地方即： **`r` 的初始值** ， **循环条件**， **以及查找边界 `r` 的移动规则**, 之所以会在这三个地方有差别， 最主要的原因就是因为 `r` 的定义：

常规写法 1 中 `l` 和 `r` 所定义的出的数组范围为 `[l, r)`， 是 **左闭右开** 的 也就是在后续的循环中， `r` 所指向的位置是 **不被** 包括在循环以内的， `r` 所代表的位置实际上是要查找的数组的**最后一个元素的后一个元素**。
- 因为是 **左闭右开** 的 `r` 初值为 `nums.size()` ，因为数组的最后一个元素的索引为 `nums[nums.size() - 1]`, 根据 `r` 定义**最后一个元素的后一个元素**即为 `r = nums.size()`;
- 因为是 **左闭右开** 的循环结束条件的判断中为 `while(l < r)` 因为对于左闭右开的区间 `[2, 2)` 这种数值是无意义的， 所以当 `r = l` 的时候， 就该结束循环了， 所以只有在 `l < r` 才继续循环
- 因为是 **左闭右开** 的 `r` 的移动规则为 `r = m` ，因为当前循环查找的为索引为 m 位置的元素(即：`（nums[m] == target）`)， 下一次应该将查找范围的右边界设置为 `m` 位置的前一个元素`（[l, m - 1]）`， 因为 `r` 指向**最后一个元素的后一个元素**， 当 `r = m` ， 下次的查找范围就为 `[l, r)`即 `[l, m - 1]`
-------
常规写法 1 中 `l` 和 `r` 的定义的范围为` [l, r]`，是 **左闭右闭** 的也就是在后续的循环中， `r` 所指向的位置是 **被** 包括在循环以内的， `r` 所代表的位置实际上是要查找的数组的**最后一个元素**。
- 因为是 **左闭右闭** 的 `r` 初值应为 `nums.size() - 1` ，因为数组的最后一个元素的索引为 `nums[nums.size() - 1]`, 根据 `r` 定义 **最后一个元素** 即为 `r = nums.size() - 1`;
- 因为是 **左闭右闭** 循环结束条件的判断中为 `while(l < r)` ，因为对于左闭右闭的区间 `[2, 2]` 这种数值是有意义的（包含元素 2）， 所以当 `r = l` 的时候， 还有一个元素应该去查找， 所以 `l <= r` 继续循环
- 因为是 **左闭右闭**  `r` 的移动规则为 `r = m - 1` ，因为当前循环被查找的为索引为 `m` 位置的元素(即：`（nums[m] == target）`) ， 下一次应该将查找范围的右边界设置为 `m` 位置的前一个元素`（[l, m - 1]）`， 因为 `r` **指向最后一个元素** , 所以让 `r = m - 1` ， 下次的查找范就为 `[l, r - 1]` 即 `[l, m - 1]`

这两种写法的区别就在于 `r` 的定义， 一种是指向要查找数组的右边界元素的后一个元素（常规解法 1）， 一种就是指向要查找的数组的右边界元素（常规解法 2）， 每次循环中 `l` 和 `r` 共同约束了本次查找的范围， 要让本次循环与上一次循环查找的范围既不重复(重复了会引起死循环)， 也不遗漏， 并且要让 `l` 和 `r` 共同约束的查找的范围变得无意义时不再进行查找（即跳出 `while`）(否则会导致访问越界)， 这其实就是所谓的**循环不变量**。归根结底就是要明确你所设置的变量的具体含义， 究竟是开区间， 还是闭区间， 让每一次循环变得有意义， 很多边界问题实际上就是没有搞清楚变量的具体含有而造成的。