题目给的用例不太明显。的另外举例子。

**输入：3，[ [0,1] , [1,2] , [2,0] ]**

对于这个用例。我把图画出来。

![X458ONUS![8_\\] ](./p__8___.png) VH4GGGI~\[7.png](https://pic.leetcode-cn.com/f99e573b6047c6b924157fb662d1171e4a7071bbca5ec7d780ffb92f1fc45379-X458ONUS*8_%5D*VH4GGGI~%5B7.png)


按照示例的解释是这样的：总共有 3 门课程。学习课程 2 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。学习课程 1 之前，你需要先完成​课程 2。这是不可能的。



---
仔细观察就发现，这个图是**有向图**，并且**形成了一个环**。（从n点出发，最终还能回到n点），所以返回false

那这个题目就变成了：
**判断有向图，是否有环。 有返回false，没有返回true**

---

那我怎么用深度优先遍历（dfs）判断有向图是否有环呢。其实很简单。

如果你写过深度优先搜索遍历。那就很简单了。

拿邻接表来解释深度优先未免有些复杂，我再画一张图

**输入：4，[ [0,2], [1,0], [1,3], [3,0] ]**


![asd.png](https://pic.leetcode-cn.com/80ff9abaadc8e86eaf86650ff117f50ad557f3badb5c19b4dc0db23a2cb927c9-asd.png)





为了清晰起见，我解释一下dfs的过程。

设置一个visit数组（开节点个数），初始为0，visit =1 表示被访问过了。 

我们要对**每一个点**进行一次深度遍历，看它是否形成环。

**对 3 dfs**：
visit[3]=0，3没被标记过，标记visit[3]=1， 对3进行dfs，访问和3相连接的所有点（0），
visit[0]=0，0没被标记过，标记visit[0]=1， 对0进行dfs，访问和0相连接的所有点(2)，
visit[2]=0，2没被标记过，标记visit[2]=1， 对2进行dfs，访问和2相连接的所有点
（没有和2相连接的点，dfs终止，并没有环，返回true， 开始回溯）

**对 2 dfs**：...
**对 1 dfs**：...
**对 0 dfs**：...

**回溯的时候要把visit还原为0。**


**递归你们都应该清楚，太麻烦就省略了，总之就是访问一个节点，就对它所有相连接的点进行dfs，这个是深度遍历的标准思路。只是加了个标记数组。**

---

**性能上的优化：我们可以在回溯的时候，把visit设置为-1，表示这个点之前已经被访问过了，走这点没环。
这样我们进入dfs后，如果visit等于 -1 ,直接返回true。**

这个性能优化提速是非常明显的。虽然没优化也能通过。